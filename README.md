# 设计原则
对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。


## 遵循原则
- 单一职责原则
- 开放封闭原则
- 里氏替换原则
- 依赖倒转原则
- 接口隔离原则
- 迪米特法则
- 合成复用原则
  
## 单一入口原则
 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。

不要设计大而全的类，要设计粒度小、功能单一的类。

单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性,


## 开放封闭原则
类的改动是通过增加代码进行的，而不是修改源代码。

添加一个新的功能，应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性等)，而非修改已有代码(修改模块、类、方法、属性等)的方式来完成。

开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。
同样的代码改动，在粗代码粒度下，可能被认定为“修改”;在细代码粒度下，可能又被认定为“扩展”。

## 依赖倒转原则
依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。

高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象(abstractions)来互相依赖。除此之外，抽象(abstractions)不要依赖具体实现细节(details)，具体实现细节(details)依赖抽象(abstractions)。

在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类,即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。

核心思想是:要面向接口编程，不要面向实现编程。

## 接口隔离原则
不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。

接口隔离原则与单一职责原则的区别：接口隔离原则主要针对模块、类、接口的设计，而单一职责原则主要针对方法的设计。

接口隔离原则提供了一种判断接口的职责是否单一的标准:通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。



## 迪米特法则
一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）

不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口

迪米特法则要求类之间尽量不要发生直接的相互依赖，如果两个类之间有直接依赖关系，那么这两个类之间的耦合度就变高，不利于系统的扩展和维护。

迪米特法则要求类之间尽量少的相互依赖，降低耦合度。

迪米特法则主要用来实现高内聚低耦合。
- 高内聚：就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中
- 松耦合：在代码中，类与类之间的依赖关系简单清晰

减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。



## 里氏替换原则
子类对象能够替换程序(program)中父类对象出现的任何地方，并且保证原来程序的逻辑行为(behavior)不变及正确性不被破坏。

子类在设计的时候，要遵守父类的行为约定(或者叫协议)。

子类不应该重新定义父类的任何属性和方法，除非这些属性和方法对于子类来说是私有的。
父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。

这里的行为约定包括:函数声明要实现的功能;对输入、输出、异常的约定;甚至包括注释中所罗列的任何特殊说明。所以我们可以通过几个点判断是否违反里氏替换原则：
- 子类违背父类声明要实现的功能：如排序函数，父类按照金额排序，子类按照时间排序
- 子类违背父类对输入、输出、异常的约定
- 子类违背父类注释中所罗列的任何特殊说明



## 合成复用原则
核心思想: 它要求在软件构建过程中，尽量使用组合/聚合的方式，而不是使用继承,因为组合/聚合可以使系统更加灵活，降低类与类之间的耦合度,继承是静态的，组合是动态的。

如果使用继承，会导致父类的任何变换都可能影响到子类的行为。

如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合


